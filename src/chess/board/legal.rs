use types::{Color, Move, MoveFlag, PieceType, SquareSet};

use crate::chess::{
    attacks,
    board::{Board, LINE},
};

impl Board {
    // Assumes that `mov` was generated by own move generation
    #[inline(always)]
    pub fn pseudo_legal(&self, mov: Move, color: Color) -> bool {
        let start = mov.start();

        // Does the piece even exists?
        let Some(piece) = self.layout.at(start) else {
            return false;
        };

        // Does `piece` has the correct color?
        if piece.color() != color {
            return false;
        }

        let target = mov.target();
        let flag = mov.flag();

        let capture = self.layout.at(target);

        // If we capture, the captured piece must exist and be the opposite color
        if flag == MoveFlag::CAPTURE && capture.is_none_or(|piece| piece.color() == color) {
            return false;
        }

        if flag == MoveFlag::KING_CASTLE {
            #[rustfmt::skip]
            return self.state.castling.pseudo_kingside(color, self.layout.all());
        }

        if flag == MoveFlag::QUEEN_CASTLE {
            #[rustfmt::skip]
            return self.state.castling.pseudo_queenside(color, self.layout.all());
        }

        let typ = piece.typ();

        // Can `piece` reach `target` from `start`?
        if typ != PieceType::Pawn {
            return attacks::by_type(typ, start, self.layout.all()).is_set(target);
        }

        // On en passant, our pawn can only attack the current en passant target square
        if flag == MoveFlag::EN_PASSANT {
            return Some(target) == self.state.en_passant;
        }

        let single = start.set().rotate(Self::PAWN_ROTATION[color]);

        if single.is_set(target) {
            return !self.layout.all().is_set(target);
        }

        let double = single.rotate(Self::PAWN_ROTATION[color]);

        if double.is_set(target) {
            return !self.layout.all().is_set(target);
        }

        // On capture, our pawn can only attack `target` squares based on `start`
        if flag == MoveFlag::CAPTURE || flag.promotion_piece().is_some() {
            return attacks::pawn(color, start).is_set(target);
        }

        false
    }

    #[inline(always)]
    pub fn legal(&self, mov: Move, color: Color) -> bool {
        const KING_PATH: [SquareSet; 2] = [SquareSet(0b0110_0000), SquareSet(0b0110_0000 << 56)];
        const QUEEN_PATH: [SquareSet; 2] = [SquareSet(0b0000_1100), SquareSet(0b0000_1100 << 56)];

        let occ = self.layout.all();

        if mov.flag() == MoveFlag::KING_CASTLE {
            return self.layout.attacked(KING_PATH[color], color, occ);
        }

        if mov.flag() == MoveFlag::QUEEN_CASTLE {
            #[rustfmt::skip]
            return self.layout.attacked(QUEEN_PATH[color], color, occ);
        }

        let start = mov.start();
        let target = mov.target();

        if mov.flag() == MoveFlag::EN_PASSANT {
            let king = self.layout.king(color);

            let capture = target.set().rotate([56, 8][color]);
            let occ = (self.layout.all() - start.set() - capture) | target.set();

            let rooks = attacks::rook(king, occ) & self.layout.orthogonal();
            let bishops = attacks::bishop(king, occ) & self.layout.diagonal();

            // Is our king in check after making the en passant capture?
            return ((rooks | bishops) & self.layout.color(!color)).is_empty();
        }

        // If the king moves, we must check if the target square is being attacked or not
        if self.layout.unchecked_at(start) == PieceType::King {
            #[rustfmt::skip]
            return self.layout.attackers(target, color, occ - start.set()).is_empty();
        }

        // The start square must either not be a blocker of our king,
        // or the piece moves towards the threat
        (self.state.blockers & start.set()).is_empty()
            || !(LINE[start][target] & self.layout.king(color).set()).is_empty()
    }
}

#[cfg(test)]
mod tests {
    use crate::{
        FEN,
        chess::{GenerationType, MoveList, Position},
    };

    #[test]
    fn pseudo_legal() {
        for fen in FEN {
            let pos = Position::from_fen(fen).unwrap();

            let mut moves = MoveList::new();
            pos.generate::<{ GenerationType::All }>(&mut moves);

            assert!(moves.iter().all(|mov| pos.pseudo_legal(mov)));
        }
    }
}
